<html>
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="viewport-fit=cover, user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
<meta charset="UTF-8"/>
<title>Clickwheel</title>
<style>
    html{
        font-family: sans-serif;
        height: 100vh;
        overflow: hidden;
    }
    body{
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        overflow: hidden;
    }
    #clickwheel{
        height: 300px;
        width: 300px;
        border: 1px solid lightgray;
        border-radius: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: radial-gradient(#ebebeb 0%, #ebebeb 68%, #bababa 80%);
        grid-column-start: 1;
        grid-row-start: 1;
    }
    #clickwheelButton{
        border: 1px solid lightgray; 
        border-radius: 100%; 
        height: 100px; 
        width: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: radial-gradient(white 0%, white 62%, #d9d9d9 90%);
        cursor: pointer;
    }
    #menuContainer{
        display: block;
        width: 300px;
        border: 1px solid lightgray;
        margin-bottom: 50px;
        height: 200px;
        font-size: 20px;
        overflow-y: hidden;
    }
    #menu{
        list-style-type: none;
        margin: 0;
        padding: 0;
    }
    #menu li{
        display: block;
        width: calc(100% - 6px);
        padding-left: 6px;
    }
    .menu-highlighted{
        background: linear-gradient(180deg, hsl(213deg 80% 70%), cornflowerblue);
        color: white;
        box-shadow: inset 0 0 1px #345ea8;
    }
    #deviceContainer{
        border: 1px solid lightgray;
        border-radius: 30px;
        padding: 40px;
        background: white;
        box-shadow: 0px 0px 5px lightgray;
    }
    #statusBar{
        background: linear-gradient(180deg, white, lightgray);
        text-align: center;
        border-bottom: 1px solid grey;
        display: grid;
        grid-column-start: 1;
        grid-column-end: 3;
        grid-row-start: 1;
    }
    @media only screen and (max-width: 450px){
        body{
            position: fixed;
            background: black;
        }
    }
    .icon-triangle, .icon-vertical-bar{
        display: inline-block;
        margin: 0;
        padding: 0;
    }
    .icon-triangle{
        height: 1em;
        width: 1em;
        background: white;
        clip-path: polygon(0% 0%, 0% 0%, 100% 50%, 0% 100%, 0% 100%)
    }
    .icon-vertical-bar{
        height: 1em;
        width: 0.5em;
        background: white;
    }
    .flip-icon{
        transform: scale(-1);
    }
    .narrow{
        transform: scaleX(0.6);
    }
    #clickwheelButtonLabelContainer{
        display: grid;
        grid-column-start: 1;
        grid-column-end: 3;
        grid-row-start: 1;
        grid-row-end: 3;
        height: 250px;
        width: 250px;
        padding: 25px;
        align-content: space-between;
        justify-content: space-between;
        pointer-events: none;
    }
    #clickwheelButtonMenu{
        font-weight: bold;
        text-align: center;
        grid-column-start: 2;
        grid-row-start: 1;
        color: white;
        z-index: 10;
    }
    #clickwheelButtonPlayPause{
        text-align: center;
        grid-column-start: 2;
        grid-row-start: 3;
    }
    #clickwheelButtonSkipBack{
        grid-column-start: 1;
        grid-row-start: 2;
        text-align: left;
    }
    #clickwheelButtonSkipForward{
        grid-column-start: 3;
        grid-row-start: 2;
        text-align: right;
    }
    #clickwheelContainer{
        display: grid;
        grid-column-start: 1;
        grid-column-end: 1;
        grid-row-start: 1;
        grid-row-end: 1;
    }
    .brick{
        width: calc(80% / 6);
        height: 80%;
        display: inline-block;
        margin: 0;
    }
    .brick.active{
        background: cornflowerblue;
    }
    .ball{
        width: 2vw;
        height: 2vw;
        background: grey;
        border: 1px solid black;
        border-radius: 100%;
        position: absolute;
    }
    #brickContainer{
        display: flex;
        flex-direction: column;
        width: 100%;
    }
    #playfieldContainer{
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 8em;
    }
    #paddle{
        background: forestgreen;
        border-radius: 1em;
        width: calc(80% / 4);
        height: calc(80% / 5 / 4);
        bottom: calc(80% / 5 / 4);
        position: fixed;
    }
</style>
</head>
<body>
    <div id="deviceContainer">
        <div id="menuContainer">
            <div id="statusBar">
                <div id="statusBar-icon-left" style="grid-column-start: 1; grid-column-end: 1; text-align: left; margin-left: 6px">ðŸ”‡</div>
                <div style="grid-column-start: 2; grid-column-end: 2; text-align: center;">Todo</div>
                <div style="grid-column-start: 3; grid-column-end: 3; text-align: right; margin-right: 6px">ðŸ”‹</div>
            </div>
            <div id="playfieldContainer" style="display: none;">
                <div id="brickContainer"></div>
                <div id="paddle" style="left: 50%;"></div>
            </div>
            <ul id="menu">
                <li>Add actual features</li>
                <li>Implement submenus</li>
                <li>Better battery</li>
                <li>Click without clicking nya</li> 
                <li>Breakout?</li>
            </ul>
        </div>
        <div id="clickwheelContainer">
            <div id="clickwheel" ontouchmove="doClickWheel()" onmousemove="doClickWheel()">
                <div id="clickwheelButton" onclick="createAudioContext(); this.innerText = ''; document.getElementById('statusBar-icon-left').style.color='#ffffff00'">Nya</div>
            </div>
            <div id="clickwheelButtonLabelContainer">
                <div id="clickwheelButtonMenu">
                    MENU
                </div>
                <div id="clickwheelButtonSkipBack" class="narrow">
                    <div class="icon-vertical-bar"></div><div class="icon-triangle flip-icon"></div><div class="icon-triangle flip-icon"></div>
                </div>
                <div id="clickwheelButtonSkipForward" class="narrow">
                    <div class="icon-triangle"></div><div class="icon-triangle"></div><div class="icon-vertical-bar"></div>
                </div>
                <div id="clickwheelButtonPlayPause">
                    <div class="icon-triangle"></div>
                    <div class="icon-vertical-bar narrow"></div><div class="icon-vertical-bar narrow"></div>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
'use strict'

function debounce(func, timeout=100){
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => { func.apply(this, args); }, timeout);
    };
}

function getOffset(el) {
  const rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}

function doClickWheel(){
    // mouse co-ords in viewport
    var touch = event.type.includes("touch") ? (event.touches[0] || event.changedTouches[0]): undefined;
    var x = event.type.includes("mouse") ? event.clientX: touch.pageX;     // Get the horizontal coordinate
    var y = event.type.includes("mouse") ? event.clientY: touch.pageY;     // Get the vertical coordinate
    // clickwheel div bounding box co-ords
    var clickWheelCoords = getOffset(document.getElementById("clickwheel"))
    // rest of the function
    var centreOfClickWheelX = clickWheelCoords["left"] + ((clickWheelCoords["right"] - clickWheelCoords["left"]) / 2)
    var centreOfClickWheelY = clickWheelCoords["top"] + ((clickWheelCoords["bottom"] - clickWheelCoords["top"]) / 2)
    var xVectorIsPositve = centreOfClickWheelX < x
    var yVectorIsPositive = centreOfClickWheelY < y

    var currentAngle = undefined // the angle relative to the centre
    var scrollDirection = undefined

    // determine angle of touch point / cursor relative to centre of clickwheel
    // compare to the last angle to decide if we have moved clockwise or widdershins
    // wheel is split into top half and bottom half
    // currentAngle == 0-180 degrees 3 o'clock to 9 o'clock, then 0-180 degrees 9 o'clock to 3 o'clock
    var opposite = y - centreOfClickWheelY
    var adjacent = x - centreOfClickWheelX
    currentAngle = Math.atan(opposite / adjacent) * 180 / Math.PI
    currentAngle = Math.floor(currentAngle)
    if (currentAngle < 0){
        currentAngle = 180 + currentAngle
    }

    // this won't work when going from the last currentAngle to the first currentAngle
    // but we'll fix that later maybe
    if (Math.abs(lastAngle - currentAngle) >= 10){
        if (currentAngle > lastAngle){
            scrollDirection = "clockwise"
        }
        else if (currentAngle < lastAngle){
            scrollDirection = "anticlockwise"
        }
    }

    // console.log(currentAngle, scrollDirection)

    // spin the wheel
    if (Math.abs(lastAngle - currentAngle) < 90){ // suppress if we pass between semicircles, avoids a glitch at 3 and 9 o'clock
        if (scrollDirection == "anticlockwise"){
            clickwheelAngle = (clickwheelAngle - 10) % 360
            document.getElementById("clickwheel").style.transform = `rotate(${clickwheelAngle}deg)`
            movePaddle("left")
            debounce_highlightMenuAtIndexPrevNext("prev")
        }
        else if (scrollDirection == "clockwise"){
            clickwheelAngle = (clickwheelAngle + 10) % 360
            document.getElementById("clickwheel").style.transform = `rotate(${clickwheelAngle}deg)`
            movePaddle("right")
            debounce_highlightMenuAtIndexPrevNext("next")
        }
    }
    // init global
    lastAngle = lastAngle ? lastAngle : currentAngle
    // update global
    if (Math.abs(lastAngle - currentAngle) >= 10){
        lastAngle = currentAngle
    }
}

function highlightMenuAtIndex(index){
    // indexes from zero
    for (var i=0; i<document.getElementById("menu").getElementsByTagName("li").length; i++){
        if ((i==index)){
            document.getElementById("menu").getElementsByTagName("li")[i].classList.add("menu-highlighted")
        }
        else if (document.getElementById("menu").getElementsByTagName("li")[i].classList.contains("menu-highlighted")){
            document.getElementById("menu").getElementsByTagName("li")[i].classList.remove("menu-highlighted")
        }
    }
}

function highlightMenuAtIndexPrevNext(direction){
    var maxIndex = document.getElementById("menu").getElementsByTagName("li").length - 1
    var currentIndex = 0
    for (var i=0; i<maxIndex + 1; i++){
        if (document.getElementById("menu").getElementsByTagName("li")[i].classList.contains("menu-highlighted")){
            currentIndex = i
            continue
        }
    }
    var nextIndex = currentIndex + 1
    var prevIndex = currentIndex - 1

    nextIndex = (nextIndex > maxIndex) ? "suppress" : nextIndex
    prevIndex = (prevIndex < 0) ? "suppress" : prevIndex

    if ((direction == "next") && (nextIndex != "suppress")){
        highlightMenuAtIndex(nextIndex);
        piezoClick();
    }
    else if ((direction == "prev") && (prevIndex != "suppress")){
        highlightMenuAtIndex(prevIndex);
        piezoClick();
    }
}

function piezoClick(){
    if (context){
        var osc = context.createOscillator(); // instantiate an oscillator
        osc.type = 'sawtooth';
        osc.frequency.value = 3000; // Hz
        osc.connect(context.destination); // connect it to the destination
        osc.start(); // start the oscillator
        osc.stop(context.currentTime + 0.001); // stop
    }
}

function createAudioContext(){
    if (!context){
        context = new (window.AudioContext || window.webkitAudioContext)();
    }
}

// globals
var clickwheelAngle = 0;
var lastAngle
const debounce_highlightMenuAtIndexPrevNext = debounce(highlightMenuAtIndexPrevNext, 10);

// audio stuff
var context

// init
function init(){
    highlightMenuAtIndex(0);
}

init();
</script>
<script>

var brickArray = [
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1]
]

// var paddlePosition = 0.5
// var paddleWidth = 0.15

function initPlayfield(){
    var rowHtml = []
    for (var i=0; i<brickArray.length; i++){
        var brickHtml = []
        for (var j=0; j<brickArray[i].length; j++){
            brickHtml.push("<div class='brick active'></div>")
        }
        rowHtml.push(brickHtml.join("\n"))
    }
    rowHtml = rowHtml.join("</div>\n<div class='brickRow'>")
    rowHtml = "<div class='brickRow'>" + rowHtml + "</div>"
    document.getElementById("brickContainer").innerHTML = rowHtml
}

function updateBricks(){
    `Update the bricks on the playfield to match the state of brickArray`
    for (var i=0; i<brickArray.length; i++){
        for (var j=0; j<brickArray[i].length; j++){
            if (brickArray[i][j] == 0){
                if (document.getElementsByClassName("brickRow")[i].getElementsByClassName("brick")[j].classList.contains("active")){
                    document.getElementsByClassName("brickRow")[i].getElementsByClassName("brick")[j].classList.remove("active")
                }
            }
            else if (brickArray[i][j] == 1){
                if (!document.getElementsByClassName("brickRow")[i].getElementsByClassName("brick")[j].classList.contains("active")){
                    document.getElementsByClassName("brickRow")[i].getElementsByClassName("brick")[j].classList.add("active")
                }
            }
        }
    }
}

function initBall(){
    if (document.getElementsByClassName("ball").length == 0){
        var ballHtml = "<div class='ball' style='left: 50%; bottom: 10%;'></div>"
        document.getElementById("playfieldContainer").innerHTML += ballHtml
    }
    
    isLose = false;

    return setInterval(() => {
        moveBall(document.getElementsByClassName("ball")[0])
    }, 10);
}

function moveBall(ballElement){
    // move the ball in the direction ballAngleDeg
    var ballLeft = parseFloat(ballElement.style.left.replace("%", ""))
    var ballBottom = parseFloat(ballElement.style.bottom.replace("%", ""))
    if (ballLeft >= 100){
        moveDistanceX = -ballSpeed
        // ballAngleDeg = ballAngleDeg * -1
    }
    if (ballBottom >= 100){
        moveDistanceY = -ballSpeed
        // ballAngleDeg = ballAngleDeg * -1
    }
    if (ballLeft <= 0){
        moveDistanceX = ballSpeed
        // ballAngleDeg = ballAngleDeg * -1
    }
    if (ballBottom <= 0){
        moveDistanceY = ballSpeed
        if (checkLoseCondition(ballElement)){
            clearInterval(ballInterval);
        }
        // ballAngleDeg = ballAngleDeg * -1
    }
    var xComponent = Math.cos(ballAngleDeg * Math.PI / 180) * moveDistanceX
    var yComponent = Math.sin(ballAngleDeg * Math.PI / 180) * moveDistanceY
    
    ballElement.style.left = (ballLeft + xComponent).toString() + "%"
    ballElement.style.bottom = (ballBottom + yComponent).toString() + "%"
    // check for collisions 
    // if collision, in horizontal or vertical plane
    // calculate angle of incidence
    // mirror it across the normal of the plane
    // set ballAngleDeg
    // repeat on interval
    // oh, if it was the bottom horizontal, you lose
    // if we hit the paddle, we can get different angles
}

function checkBrickCollisions(ballElement){
    var ballOffsets = ballElement.getBoundingClientRect();
    var ballTop = ballOffsets.top;
    var ballLeft = ballOffsets.left;
    var ballRight = ballOffsets.right;
    var ballBottom = ballOffsets.bottom;
    var ballX = ballOffsets.x;
    var ballY = ballOffsets.y;
    
    for (var i=0; i<document.getElementsByClassName("brick").length; i++){
        if (document.getElementsByClassName("brick")[i].classList.contains("active")){
            var brickOffsets = document.getElementsByClassName("brick")[i].getBoundingClientRect();
            var top = brickOffsets.top;
            var left = brickOffsets.left;
            var right = brickOffsets.right;
            var bottom = brickOffsets.bottom;

            if ((ballRight >= left) && (ballLeft <= right) && (ballBottom >= top) && (ballTop <= bottom)){
                document.getElementsByClassName("brick")[i].classList.remove("active")

                // figure out which side is closest to the ball
                // then assume that is the side we hit first
                // and rebound off it
                var topDelta = Math.abs(ballBottom - top)
                var leftDelta = Math.abs(ballRight - left)
                var rightDelta = Math.abs(ballLeft - right)
                var bottomDelta = Math.abs(ballTop - bottom)

                var minDelta = Math.min(topDelta, leftDelta, rightDelta, bottomDelta)

                if (topDelta == minDelta){
                    changeDirectionIfCollide("bottom")
                }
                else if (leftDelta == minDelta){
                    changeDirectionIfCollide("right")
                }
                else if (rightDelta == minDelta){
                    changeDirectionIfCollide("left")
                }
                else if (bottomDelta == minDelta){
                    changeDirectionIfCollide("top")
                }
            }
        }
    }
}

function changeDirectionIfCollide(plane){
    if (plane == "top"){
        moveDistanceY = -ballSpeed
    }
    else if (plane == "bottom"){
        moveDistanceY = ballSpeed
    }
    else if (plane == "left"){
        moveDistanceX = ballSpeed
    }
    else if (plane == "right"){
        moveDistanceX = -ballSpeed
    }
}

function initCheckBallCollisions(){
    return setInterval(function(){debounce(checkBrickCollisions(document.getElementsByClassName("ball")[0]), 15)}, 1)
}

function movePaddle(direction){
    var paddlePosition = parseFloat(document.getElementById("paddle").style.left.replace("%", ""))
    if ((direction == "left") && (paddlePosition > 10)){
        paddlePosition -= 3
    }
    else if ((direction == "right") && (paddlePosition < 90)){
        paddlePosition += 3
    }
    else if (direction == "home"){
        // return to centre
        paddlePosition = 50
    }
    document.getElementById("paddle").style.left = paddlePosition.toString() + "%"
}

function initPaddleKeyboardEvents(){
    window.onkeydown = function(){
        if (event.key == "ArrowLeft"){
            movePaddle("left")
        }

        else if (event.key == "ArrowRight"){
            movePaddle("right")
        }

        if (isLose){
            if (event.key == " ")
                ballInterval = initBall()
        }
    }
}

function checkLoseCondition(ballElement){
    var ballOffsets = ballElement.getBoundingClientRect();
    var ballLeft = ballOffsets.left;
    var ballRight = ballOffsets.right;
    var ballBottom = ballOffsets.bottom;

    var paddleOffsets = document.getElementById("paddle").getBoundingClientRect();
    var paddleLeft = paddleOffsets.left;
    var paddleRight = paddleOffsets.right;
    var paddleTop = paddleOffsets.top;

    if (ballBottom > paddleTop){
        if ((ballLeft <= paddleLeft) || (ballRight >= paddleRight)){
            isLose = true
            return true
        }
    }
    return false
}

function breakoutInit(){
    document.getElementById("playfieldContainer").style.display = "flex";
    document.getElementById("menu").style.display = "none";
    initPlayfield();
    ballInterval = initBall();
    initCheckBallCollisions();
    initPaddleKeyboardEvents();
}

// globals
var ballAngleDeg = 45
var ballSpeed = 0.5
var moveDistanceX = ballSpeed // distance for ball to move in percent
var moveDistanceY = ballSpeed
var ballInterval
var isLose = false
</script>
</html>